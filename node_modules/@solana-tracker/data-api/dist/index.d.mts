import { EventEmitter } from 'events';

interface TokenInfo {
    name: string;
    symbol: string;
    mint: string;
    uri?: string;
    decimals: number;
    description?: string;
    image?: string;
    hasFileMetaData?: boolean;
    strictSocials?: {
        twitter?: string;
        telegram?: string;
        discord?: string;
        website?: string;
    };
    showName?: boolean;
    twitter?: string;
    telegram?: string;
    website?: string;
    discord?: string;
    createdOn?: string;
}
interface TokenSecurity {
    freezeAuthority: string | null;
    mintAuthority: string | null;
}
interface TokenPoolTxns {
    buys: number;
    total: number;
    volume: number;
    sells: number;
}
interface TokenValuePair {
    quote: number;
    usd: number;
}
interface PoolInfo {
    poolId: string;
    liquidity: TokenValuePair;
    price: TokenValuePair;
    tokenSupply: number;
    lpBurn: number;
    tokenAddress: string;
    marketCap: TokenValuePair;
    market: string;
    quoteToken: string;
    decimals: number;
    security: TokenSecurity;
    lastUpdated: number;
    deployer?: string;
    txns?: TokenPoolTxns;
    curvePercentage?: number;
    curve?: string;
    createdAt?: number;
    bundleId?: string;
}
interface PriceChangeData {
    priceChangePercentage: number;
}
interface TokenEvents {
    "1m"?: PriceChangeData;
    "5m"?: PriceChangeData;
    "15m"?: PriceChangeData;
    "30m"?: PriceChangeData;
    "1h"?: PriceChangeData;
    "2h"?: PriceChangeData;
    "3h"?: PriceChangeData;
    "4h"?: PriceChangeData;
    "5h"?: PriceChangeData;
    "6h"?: PriceChangeData;
    "12h"?: PriceChangeData;
    "24h"?: PriceChangeData;
}
interface TokenRisk {
    rugged: boolean;
    risks: TokenRiskFactor[];
    score: number;
    jupiterVerified?: boolean;
}
interface TokenRiskFactor {
    name: string;
    description: string;
    level: "warning" | "danger";
    score: number;
}
interface TokenDetailResponse {
    token: TokenInfo;
    pools: PoolInfo[];
    events: TokenEvents;
    risk: TokenRisk;
    buys: number;
    sells: number;
    txns: number;
    holders?: number;
}
interface Holder {
    wallet: string;
    amount: number;
    value: TokenValuePair;
    percentage: number;
}
interface TopHolder {
    address: string;
    amount: number;
    percentage: number;
    value: TokenValuePair;
}
interface TokenHoldersResponse {
    total: number;
    accounts: Holder[];
}
interface AthPrice {
    highest_price: number;
    timestamp: number;
}
interface DeployerToken {
    name: string;
    symbol: string;
    mint: string;
    image?: string;
    decimals: number;
    hasSocials: boolean;
    poolAddress?: string;
    liquidityUsd: number;
    marketCapUsd: number;
    priceUsd: number;
    lpBurn: number;
    market: string;
    freezeAuthority: string | null;
    mintAuthority: string | null;
    createdAt: number;
    lastUpdated: number;
    buys: number;
    sells: number;
    totalTransactions: number;
}
interface DeployerTokensResponse {
    total: number;
    tokens: DeployerToken[];
}
interface SearchParams {
    query?: string;
    page?: number;
    limit?: number;
    sortBy?: string;
    sortOrder?: string;
    showAllPools?: boolean;
    minCreatedAt?: number;
    maxCreatedAt?: number;
    minLiquidity?: number;
    maxLiquidity?: number;
    minMarketCap?: number;
    maxMarketCap?: number;
    minVolume?: number;
    maxVolume?: number;
    volumeTimeframe?: string;
    minBuys?: number;
    maxBuys?: number;
    minSells?: number;
    maxSells?: number;
    minTotalTransactions?: number;
    maxTotalTransactions?: number;
    lpBurn?: number;
    market?: string;
    freezeAuthority?: string;
    mintAuthority?: string;
    deployer?: string;
    status?: string;
    showPriceChanges?: boolean;
    [key: string]: string | number | boolean | undefined;
}
interface SearchResult {
    name: string;
    symbol: string;
    mint: string;
    decimals: number;
    image?: string;
    holders?: number;
    jupiter?: boolean;
    verified?: boolean;
    liquidityUsd: number;
    marketCapUsd: number;
    priceUsd: number;
    lpBurn: number;
    market: string;
    freezeAuthority: string | null;
    mintAuthority: string | null;
    poolAddress: string;
    totalBuys: number;
    totalSells: number;
    totalTransactions: number;
    volume: number;
    volume_5m?: number;
    volume_15m?: number;
    volume_30m?: number;
    volume_1h?: number;
    volume_6h?: number;
    volume_12h?: number;
    volume_24h?: number;
}
interface SearchResponse {
    status: string;
    data: SearchResult[];
}
interface TokenOverview {
    latest: TokenDetailResponse[];
    graduating: TokenDetailResponse[];
    graduated: TokenDetailResponse[];
}
interface PriceData {
    price: number;
    liquidity: number;
    marketCap: number;
    lastUpdated: number;
}
interface PriceHistoryData {
    current: number;
    "3d"?: number;
    "5d"?: number;
    "7d"?: number;
    "14d"?: number;
    "30d"?: number;
}
interface PriceTimestampData {
    price: number;
    timestamp: number;
    timestamp_unix: number;
    pool: string;
}
interface PriceRangeData {
    token: string;
    price: {
        lowest: {
            price: number;
            time: number;
        };
        highest: {
            price: number;
            time: number;
        };
    };
}
interface PriceChange {
    timeframe: string;
    percentage: number;
}
interface MultiPriceResponse {
    [tokenAddress: string]: PriceData;
}
interface WalletTokenData {
    address: string;
    balance: number;
    value: number;
    price: TokenValuePair;
    marketCap: TokenValuePair;
    liquidity: TokenValuePair;
}
interface WalletBasicResponse {
    tokens: WalletTokenData[];
    total: number;
    totalSol: number;
}
interface TokenMetadata$1 {
    name: string;
    symbol: string;
    image?: string;
    decimals: number;
}
interface TradeTokenInfo {
    address: string;
    amount: number;
    token: TokenMetadata$1;
}
interface TradeTransaction {
    tx: string;
    from?: TradeTokenInfo;
    to?: TradeTokenInfo;
    amount?: number;
    priceUsd?: number;
    volume?: number;
    solVolume?: number;
    type?: string;
    wallet: string;
    time: number;
    program: string;
    pools?: string[];
    token?: {
        from: TradeTokenInfo;
        to: TradeTokenInfo;
    };
}
interface TradesResponse {
    trades: TradeTransaction[];
    nextCursor?: number;
    hasNextPage?: boolean;
}
interface WalletTokenDetail {
    token: TokenInfo;
    pools?: PoolInfo[];
    events?: TokenEvents;
    risk?: TokenRisk;
    balance: number;
    value: number;
}
interface WalletResponse {
    tokens: WalletTokenDetail[];
    total: number;
    totalSol: number;
    timestamp: string;
}
interface OHLCVData {
    open: number;
    close: number;
    low: number;
    high: number;
    volume: number;
    time: number;
}
interface ChartResponse {
    oclhv: OHLCVData[];
}
interface HolderChartData {
    holders: number;
    time: number;
}
interface HoldersChartResponse {
    holders: HolderChartData[];
}
interface PnLData {
    holding: number;
    held: number;
    sold: number;
    realized: number;
    unrealized: number;
    total: number;
    total_sold: number;
    total_invested: number;
    average_buy_amount: number;
    current_value: number;
    cost_basis: number;
    sold_usd?: number;
    first_buy_time?: number;
    last_buy_time?: number;
    last_sell_time?: number;
    last_trade_time?: number;
    buy_transactions?: number;
    sell_transactions?: number;
    total_transactions?: number;
}
interface PnLSummary {
    realized: number;
    unrealized: number;
    total: number;
    totalInvested: number;
    averageBuyAmount: number;
    totalWins: number;
    totalLosses: number;
    winPercentage: number;
    lossPercentage: number;
    neutralPercentage?: number;
}
interface PnLResponse {
    tokens: {
        [tokenAddress: string]: PnLData;
    };
    summary: PnLSummary;
}
interface TokenPnLResponse extends PnLData {
}
interface FirstBuyerData extends PnLData {
    wallet: string;
    first_buy_time: number;
    last_transaction_time: number;
}
interface TopTrader {
    wallet: string;
    summary: PnLSummary;
}
interface TopTradersResponse {
    wallets: TopTrader[];
}
interface TimeframeStats {
    buyers: number;
    sellers: number;
    volume: {
        buys: number;
        sells: number;
        total: number;
    };
    transactions: number;
    buys: number;
    sells: number;
    wallets: number;
    price: number;
    priceChangePercentage: number;
}
interface TokenStats {
    "1m"?: TimeframeStats;
    "5m"?: TimeframeStats;
    "15m"?: TimeframeStats;
    "30m"?: TimeframeStats;
    "1h"?: TimeframeStats;
    "4h"?: TimeframeStats;
    "24h"?: TimeframeStats;
}

declare class DataApiError extends Error {
    status?: number | undefined;
    code?: string | undefined;
    constructor(message: string, status?: number | undefined, code?: string | undefined);
}
declare class RateLimitError extends DataApiError {
    retryAfter?: number | undefined;
    constructor(message: string, retryAfter?: number | undefined);
}
declare class ValidationError extends DataApiError {
    constructor(message: string);
}
/**
 * Config options for the Solana Tracker Data API
 */
interface DataApiConfig {
    /** Your API key from solanatracker.io */
    apiKey: string;
    /** Optional base URL override */
    baseUrl?: string;
}
/**
 * Solana Tracker Data API client
 */
declare class Client {
    private apiKey;
    private baseUrl;
    /**
     * Creates a new instance of the Solana Tracker Data API client
     * @param config Configuration options including API key
     */
    constructor(config: DataApiConfig);
    /**
     * Makes a request to the API
     * @param endpoint The API endpoint
     * @param options Additional fetch options
     * @returns The API response
     */
    private request;
    /**
     * Validates a Solana public key
     * @param address The address to validate
     * @param paramName The parameter name for error messaging
     * @throws ValidationError if the address is invalid
     */
    private validatePublicKey;
    /**
     * Get comprehensive information about a specific token
     * @param tokenAddress The token's mint address
     * @returns Detailed token information
     */
    getTokenInfo(tokenAddress: string): Promise<TokenDetailResponse>;
    /**
     * Get token information by searching with a pool address
     * @param poolAddress The pool address
     * @returns Detailed token information
     */
    getTokenByPool(poolAddress: string): Promise<TokenDetailResponse>;
    /**
     * Get token holders information
     * @param tokenAddress The token's mint address
     * @returns Information about token holders
     */
    getTokenHolders(tokenAddress: string): Promise<TokenHoldersResponse>;
    /**
     * Get top 20 token holders
     * @param tokenAddress The token's mint address
     * @returns Top holders information
     */
    getTopHolders(tokenAddress: string): Promise<TopHolder[]>;
    /**
     * Get the all-time high price for a token
     * @param tokenAddress The token's mint address
     * @returns All-time high price data
     */
    getAthPrice(tokenAddress: string): Promise<AthPrice>;
    /**
     * Get tokens created by a specific wallet
     * @param wallet The deployer wallet address
     * @returns List of tokens created by the deployer
     */
    getTokensByDeployer(wallet: string): Promise<DeployerTokensResponse>;
    /**
     * Search for tokens with flexible filtering options
     * @param params Search parameters and filters
     * @returns Search results
     */
    searchTokens(params: SearchParams): Promise<SearchResponse>;
    /**
     * Get the latest tokens
     * @param page Page number (1-10)
     * @returns List of latest tokens
     */
    getLatestTokens(page?: number): Promise<TokenDetailResponse[]>;
    /**
     * Get information about multiple tokens
     * @param tokenAddresses Array of token addresses
     * @returns Information about multiple tokens
     */
    getMultipleTokens(tokenAddresses: string[]): Promise<TokenDetailResponse[]>;
    /**
     * Get trending tokens
     * @param timeframe Optional timeframe for trending calculation
     * @returns List of trending tokens
     */
    getTrendingTokens(timeframe?: string): Promise<TokenDetailResponse[]>;
    /**
     * Get tokens sorted by volume
     * @param timeframe Optional timeframe for volume calculation
     * @returns List of tokens sorted by volume
     */
    getTokensByVolume(timeframe?: string): Promise<TokenDetailResponse[]>;
    /**
     * Get an overview of latest, graduating, and graduated tokens
     * @returns Token overview
     */
    getTokenOverview(): Promise<TokenOverview>;
    /**
     * Get graduated tokens
     * @returns List of graduated tokens
     */
    getGraduatedTokens(): Promise<TokenDetailResponse[]>;
    /**
     * Get price information for a token
     * @param tokenAddress The token's mint address
     * @param priceChanges Include price change percentages
     * @returns Price data
     */
    getPrice(tokenAddress: string, priceChanges?: boolean): Promise<PriceData>;
    /**
     * Get historic price information for a token
     * @param tokenAddress The token's mint address
     * @returns Historic price data
     */
    getPriceHistory(tokenAddress: string): Promise<PriceHistoryData>;
    /**
     * Get price at a specific timestamp
     * @param tokenAddress The token's mint address
     * @param timestamp Unix timestamp
     * @returns Price at the specified timestamp
     */
    getPriceAtTimestamp(tokenAddress: string, timestamp: number): Promise<PriceTimestampData>;
    /**
     * Get lowest and highest price in a time range
     * @param tokenAddress The token's mint address
     * @param timeFrom Start time (unix timestamp)
     * @param timeTo End time (unix timestamp)
     * @returns Price range data
     */
    getPriceRange(tokenAddress: string, timeFrom: number, timeTo: number): Promise<PriceRangeData>;
    /**
     * Get price information for a token (POST method)
     * @param tokenAddress The token's mint address
     * @param priceChanges Include price change percentages
     * @returns Price data
     */
    postPrice(tokenAddress: string, priceChanges?: boolean): Promise<PriceData>;
    /**
     * Get price information for multiple tokens
     * @param tokenAddresses Array of token addresses
     * @param priceChanges Include price change percentages
     * @returns Price data for multiple tokens
     */
    getMultiplePrices(tokenAddresses: string[], priceChanges?: boolean): Promise<MultiPriceResponse>;
    /**
     * Get price information for multiple tokens (POST method)
     * @param tokenAddresses Array of token addresses
     * @param priceChanges Include price change percentages
     * @returns Price data for multiple tokens
     */
    postMultiplePrices(tokenAddresses: string[], priceChanges?: boolean): Promise<MultiPriceResponse>;
    /**
     * Get basic wallet information
     * @param owner Wallet address
     * @returns Basic wallet data
     */
    getWalletBasic(owner: string): Promise<WalletBasicResponse>;
    /**
     * Get all tokens in a wallet
     * @param owner Wallet address
     * @returns Detailed wallet data
     */
    getWallet(owner: string): Promise<WalletResponse>;
    /**
     * Get wallet tokens with pagination
     * @param owner Wallet address
     * @param page Page number
     * @returns Paginated wallet data
     */
    getWalletPage(owner: string, page: number): Promise<WalletResponse>;
    /**
     * Get wallet trades
     * @param owner Wallet address
     * @param cursor Pagination cursor
     * @param showMeta Include token metadata
     * @param parseJupiter Parse Jupiter swaps
     * @param hideArb Hide arbitrage transactions
     * @returns Wallet trades data
     */
    getWalletTrades(owner: string, cursor?: number, showMeta?: boolean, parseJupiter?: boolean, hideArb?: boolean): Promise<TradesResponse>;
    /**
     * Get trades for a token
     * @param tokenAddress Token address
     * @param cursor Pagination cursor
     * @param showMeta Include token metadata
     * @param parseJupiter Parse Jupiter swaps
     * @param hideArb Hide arbitrage transactions
     * @returns Token trades data
     */
    getTokenTrades(tokenAddress: string, cursor?: number, showMeta?: boolean, parseJupiter?: boolean, hideArb?: boolean): Promise<TradesResponse>;
    /**
     * Get trades for a specific token and pool
     * @param tokenAddress Token address
     * @param poolAddress Pool address
     * @param cursor Pagination cursor
     * @param showMeta Include token metadata
     * @param parseJupiter Parse Jupiter swaps
     * @param hideArb Hide arbitrage transactions
     * @returns Pool-specific token trades data
     */
    getPoolTrades(tokenAddress: string, poolAddress: string, cursor?: number, showMeta?: boolean, parseJupiter?: boolean, hideArb?: boolean): Promise<TradesResponse>;
    /**
     * Get trades for a specific token, pool, and wallet
     * @param tokenAddress Token address
     * @param poolAddress Pool address
     * @param owner Wallet address
     * @param cursor Pagination cursor
     * @param showMeta Include token metadata
     * @param parseJupiter Parse Jupiter swaps
     * @param hideArb Hide arbitrage transactions
     * @returns User-specific pool trades data
     */
    getUserPoolTrades(tokenAddress: string, poolAddress: string, owner: string, cursor?: number, showMeta?: boolean, parseJupiter?: boolean, hideArb?: boolean): Promise<TradesResponse>;
    /**
     * Get trades for a specific token and wallet
     * @param tokenAddress Token address
     * @param owner Wallet address
     * @param cursor Pagination cursor
     * @param showMeta Include token metadata
     * @param parseJupiter Parse Jupiter swaps
     * @param hideArb Hide arbitrage transactions
     * @returns User-specific token trades data
     */
    getUserTokenTrades(tokenAddress: string, owner: string, cursor?: number, showMeta?: boolean, parseJupiter?: boolean, hideArb?: boolean): Promise<TradesResponse>;
    /**
     * Get OHLCV data for a token
     * @param tokenAddress Token address
     * @param type Time interval (e.g., "1s", "1m", "1h", "1d")
     * @param timeFrom Start time (Unix timestamp in seconds)
     * @param timeTo End time (Unix timestamp in seconds)
     * @param marketCap Return chart for market cap instead of pricing
     * @param removeOutliers Disable outlier removal if set to false (default: true)
     * @returns OHLCV chart data
     */
    getChartData(tokenAddress: string, type?: string, timeFrom?: number, timeTo?: number, marketCap?: boolean, removeOutliers?: boolean): Promise<ChartResponse>;
    /**
     * Get OHLCV data for a specific token and pool
     * @param tokenAddress Token address
     * @param poolAddress Pool address
     * @param type Time interval (e.g., "1s", "1m", "1h", "1d")
     * @param timeFrom Start time (Unix timestamp in seconds)
     * @param timeTo End time (Unix timestamp in seconds)
     * @param marketCap Return chart for market cap instead of pricing
     * @param removeOutliers Disable outlier removal if set to false (default: true)
     * @returns OHLCV chart data for a specific pool
     */
    getPoolChartData(tokenAddress: string, poolAddress: string, type?: string, timeFrom?: number, timeTo?: number, marketCap?: boolean, removeOutliers?: boolean): Promise<ChartResponse>;
    /**
     * Get holder count chart data
     * @param tokenAddress Token address
     * @param type Time interval (e.g., "1s", "1m", "1h", "1d")
     * @param timeFrom Start time (Unix timestamp in seconds)
     * @param timeTo End time (Unix timestamp in seconds)
     * @returns Holder count chart data
     */
    getHoldersChart(tokenAddress: string, type?: string, timeFrom?: number, timeTo?: number): Promise<HoldersChartResponse>;
    /**
     * Get PnL data for all positions of a wallet
     * @param wallet Wallet address
     * @param showHistoricPnL Add PnL data for 1d, 7d and 30d intervals (BETA)
     * @param holdingCheck Additional check for current holding value
     * @param hideDetails Return only summary without data for each token
     * @returns Wallet PnL data
     */
    getWalletPnL(wallet: string, showHistoricPnL?: boolean, holdingCheck?: boolean, hideDetails?: boolean): Promise<PnLResponse>;
    /**
     * Get the first 100 buyers of a token with PnL data
     * @param tokenAddress Token address
     * @returns First buyers data with PnL
     */
    getFirstBuyers(tokenAddress: string): Promise<FirstBuyerData[]>;
    /**
     * Get PnL data for a specific token in a wallet
     * @param wallet Wallet address
     * @param tokenAddress Token address
     * @returns Token-specific PnL data
     */
    getTokenPnL(wallet: string, tokenAddress: string): Promise<TokenPnLResponse>;
    /**
     * Get the most profitable traders across all tokens
     * @param page Page number (optional)
     * @param expandPnL Include detailed PnL data for each token
     * @param sortBy Sort results by metric ("total" or "winPercentage")
     * @returns Top traders data
     */
    getTopTraders(page?: number, expandPnL?: boolean, sortBy?: 'total' | 'winPercentage'): Promise<TopTradersResponse>;
    /**
     * Get top 100 traders by PnL for a token
     * @param tokenAddress Token address
     * @returns Top traders for a specific token
     */
    getTokenTopTraders(tokenAddress: string): Promise<FirstBuyerData[]>;
    /**
     * Get detailed stats for a token over various time intervals
     * @param tokenAddress Token address
     * @returns Detailed token stats
     */
    getTokenStats(tokenAddress: string): Promise<TokenStats>;
    /**
     * Get detailed stats for a specific token and pool
     * @param tokenAddress Token address
     * @param poolAddress Pool address
     * @returns Detailed token-pool stats
     */
    getPoolStats(tokenAddress: string, poolAddress: string): Promise<TokenStats>;
}

/**
 * WebSocket polyfill for Node.js environments
 */
declare global {
    interface Window {
        WebSocket: typeof WebSocket;
    }
}

/**
 * Room types for the WebSocket data stream
 */
declare enum DatastreamRoom {
    LATEST = "latest",
    PRICE_BY_TOKEN = "price-by-token",
    PRICE_BY_POOL = "price",
    TOKEN_TRANSACTIONS = "transaction",
    WALLET_TRANSACTIONS = "wallet",
    GRADUATING = "graduating",
    GRADUATED = "graduated",
    METADATA = "metadata",
    HOLDERS = "holders",
    TOKEN_CHANGES = "token",
    POOL_CHANGES = "pool"
}
/**
 * Configuration for the Datastream client
 */
interface DatastreamConfig {
    /**
     * WebSocket URL for the data stream found on your Dashboard.
     */
    wsUrl: string;
    /**
     * Whether to automatically reconnect on disconnect
     * @default true
     */
    autoReconnect?: boolean;
    /**
     * Initial reconnect delay in milliseconds
     * @default 2500
     */
    reconnectDelay?: number;
    /**
     * Maximum reconnect delay in milliseconds
     * @default 4500
     */
    reconnectDelayMax?: number;
    /**
     * Randomization factor for reconnect delay
     * @default 0.5
     */
    randomizationFactor?: number;
}
interface SubscribeResponse<T = any> {
    room: string;
    /**
     * Register a listener for this subscription
     * @param callback Function to handle incoming data
     * @returns Object with unsubscribe method
     */
    on(callback: (data: T) => void): {
        unsubscribe: () => void;
    };
}
/**
 * Subscription methods for the Datastream client
 */
declare class SubscriptionMethods {
    private ds;
    price: PriceSubscriptions;
    tx: TransactionSubscriptions;
    constructor(datastream: Datastream);
    /**
     * Subscribe to latest tokens and pools
     */
    latest(): SubscribeResponse<PoolUpdate>;
    /**
     * Subscribe to graduating tokens
     * @param marketCapThresholdSOL Optional market cap threshold in SOL
     */
    graduating(marketCapThresholdSOL?: number): SubscribeResponse<PoolUpdate>;
    /**
     * Subscribe to graduated tokens
     */
    graduated(): SubscribeResponse<PoolUpdate>;
    /**
     * Subscribe to token metadata updates
     * @param tokenAddress The token address
     */
    metadata(tokenAddress: string): SubscribeResponse<TokenMetadata>;
    /**
     * Subscribe to holder count updates for a token
     * @param tokenAddress The token address
     */
    holders(tokenAddress: string): SubscribeResponse<HolderUpdate>;
    /**
     * Subscribe to token changes (any pool)
     * @param tokenAddress The token address
     */
    token(tokenAddress: string): SubscribeResponse<PoolUpdate>;
    /**
     * Subscribe to pool changes
     * @param poolId The pool address
     */
    pool(poolId: string): SubscribeResponse<PoolUpdate>;
}
/**
 * Price-related subscription methods
 */
declare class PriceSubscriptions {
    private ds;
    constructor(datastream: Datastream);
    /**
     * Subscribe to price updates for a token's primary/largest pool
     * @param tokenAddress The token address
     */
    token(tokenAddress: string): SubscribeResponse<PriceUpdate>;
    /**
     * Subscribe to all price updates for a token across all pools
     * @param tokenAddress The token address
     */
    allPoolsForToken(tokenAddress: string): SubscribeResponse<PriceUpdate>;
    /**
     * Subscribe to price updates for a specific pool
     * @param poolId The pool address
     */
    pool(poolId: string): SubscribeResponse<PriceUpdate>;
}
/**
 * Transaction-related subscription methods
 */
declare class TransactionSubscriptions {
    private ds;
    constructor(datastream: Datastream);
    /**
     * Subscribe to transactions for a token across all pools
     * @param tokenAddress The token address
     */
    token(tokenAddress: string): SubscribeResponse<TokenTransaction>;
    /**
     * Subscribe to transactions for a specific token and pool
     * @param tokenAddress The token address
     * @param poolId The pool address
     */
    pool(tokenAddress: string, poolId: string): SubscribeResponse<TokenTransaction>;
    /**
     * Subscribe to transactions for a specific wallet
     * @param walletAddress The wallet address
     */
    wallet(walletAddress: string): SubscribeResponse<WalletTransaction>;
}
/**
 * WebSocket service for real-time data streaming from Solana Tracker
 */
declare class Datastream extends EventEmitter {
    subscribe: SubscriptionMethods;
    private wsUrl;
    private socket;
    private transactionSocket;
    private reconnectAttempts;
    private reconnectDelay;
    private reconnectDelayMax;
    private randomizationFactor;
    private subscribedRooms;
    private transactions;
    private autoReconnect;
    private isConnecting;
    /**
     * Creates a new Datastream client for real-time Solana Tracker data
     * @param config Configuration options
     */
    constructor(config: DatastreamConfig);
    /**
     * Connects to the WebSocket server
     * @returns Promise that resolves when connected
     */
    connect(): Promise<void>;
    /**
     * Creates a WebSocket connection
     * @param type Socket type ('main' or 'transaction')
     * @returns Promise that resolves when connected
     */
    private createSocket;
    /**
     * Sets up WebSocket event listeners
     * @param socket The WebSocket connection
     * @param type Socket type ('main' or 'transaction')
     */
    private setupSocketListeners;
    /**
     * Disconnects from the WebSocket server
     */
    disconnect(): void;
    /**
     * Handles reconnection to the WebSocket server
     */
    private reconnect;
    /**
     * Subscribes to a data room
     * @param room The room name to join
     * @returns Response with room name and on() method for listening
     * @internal Used by SubscriptionMethods
     */
    _subscribe<T = any>(room: string): SubscribeResponse<T>;
    on(event: string | symbol, listener: (...args: any[]) => void): this;
    once(event: string | symbol, listener: (...args: any[]) => void): this;
    off(event: string | symbol, listener: (...args: any[]) => void): this;
    removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
    removeAllListeners(event?: string | symbol): this;
    listeners(event: string | symbol): Function[];
    /**
     * Unsubscribes from a data room
     * @param room The room name to leave
     * @returns Reference to this instance for chaining
     */
    unsubscribe(room: string): Datastream;
    /**
     * Resubscribes to all previously subscribed rooms after reconnection
     */
    private resubscribeToRooms;
    /**
     * Get the current connection status
     * @returns True if connected, false otherwise
     */
    isConnected(): boolean;
}
interface TokenTransaction {
    tx: string;
    amount: number;
    priceUsd: number;
    volume: number;
    volumeSol?: number;
    type: 'buy' | 'sell';
    wallet: string;
    time: number;
    program: string;
    pools?: string[];
}
interface PriceUpdate {
    price: number;
    price_quote: number;
    pool: string;
    token: string;
    time: number;
}
interface PoolUpdate {
    liquidity: {
        quote: number;
        usd: number;
    };
    price: {
        quote: number;
        usd: number;
    };
    tokenSupply: number;
    lpBurn: number;
    tokenAddress: string;
    marketCap: {
        quote: number;
        usd: number;
    };
    decimals: number;
    security: {
        freezeAuthority: string | null;
        mintAuthority: string | null;
    };
    quoteToken: string;
    market: string;
    deployer?: string;
    lastUpdated: number;
    createdAt?: number;
    poolId: string;
    curvePercentage?: number;
    curve?: string;
    txns?: {
        buys: number;
        total: number;
        volume: number;
        sells: number;
    };
    bundleId?: string;
}
interface HolderUpdate {
    total: number;
}
interface WalletTransaction {
    tx: string;
    amount: number;
    priceUsd: number;
    solVolume: number;
    volume: number;
    type: 'buy' | 'sell';
    wallet: string;
    time: number;
    program: string;
    token?: {
        from: {
            name: string;
            symbol: string;
            image?: string;
            decimals: number;
            amount: number;
            address: string;
        };
        to: {
            name: string;
            symbol: string;
            image?: string;
            decimals: number;
            amount: number;
            address: string;
        };
    };
}
interface TokenMetadata {
    name: string;
    symbol: string;
    mint: string;
    uri?: string;
    decimals: number;
    hasFileMetaData?: boolean;
    createdOn?: string;
    description?: string;
    image?: string;
    showName?: boolean;
    twitter?: string;
    telegram?: string;
    website?: string;
    strictSocials?: {
        twitter?: string;
        telegram?: string;
        website?: string;
    };
}

export { type AthPrice, type ChartResponse, Client, type DataApiConfig, DataApiError, Datastream, type DatastreamConfig, DatastreamRoom, type DeployerToken, type DeployerTokensResponse, type FirstBuyerData, type Holder, type HolderChartData, type HolderUpdate, type HoldersChartResponse, type MultiPriceResponse, type OHLCVData, type PnLData, type PnLResponse, type PnLSummary, type PoolInfo, type PoolUpdate, type PriceChange, type PriceChangeData, type PriceData, type PriceHistoryData, type PriceRangeData, type PriceTimestampData, type PriceUpdate, RateLimitError, type SearchParams, type SearchResponse, type SearchResult, type TimeframeStats, type TokenDetailResponse, type TokenEvents, type TokenHoldersResponse, type TokenInfo, type TokenMetadata, type TokenOverview, type TokenPnLResponse, type TokenPoolTxns, type TokenRisk, type TokenRiskFactor, type TokenSecurity, type TokenStats, type TokenTransaction, type TokenValuePair, type TopHolder, type TopTrader, type TopTradersResponse, type TradeTokenInfo, type TradeTransaction, type TradesResponse, ValidationError, type WalletBasicResponse, type WalletResponse, type WalletTokenData, type WalletTokenDetail, type WalletTransaction };
