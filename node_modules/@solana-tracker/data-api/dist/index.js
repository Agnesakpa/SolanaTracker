"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Client: () => Client,
  DataApiError: () => DataApiError,
  Datastream: () => Datastream,
  DatastreamRoom: () => DatastreamRoom,
  RateLimitError: () => RateLimitError,
  ValidationError: () => ValidationError
});
module.exports = __toCommonJS(index_exports);

// src/data-api.ts
var DataApiError = class extends Error {
  constructor(message, status, code) {
    super(message);
    this.status = status;
    this.code = code;
    this.name = "DataApiError";
  }
};
var RateLimitError = class extends DataApiError {
  constructor(message, retryAfter) {
    super(message, 429, "RATE_LIMIT_EXCEEDED");
    this.retryAfter = retryAfter;
    this.name = "RateLimitError";
  }
};
var ValidationError = class extends DataApiError {
  constructor(message) {
    super(message, 400, "VALIDATION_ERROR");
    this.name = "ValidationError";
  }
};
var Client = class {
  /**
   * Creates a new instance of the Solana Tracker Data API client
   * @param config Configuration options including API key
   */
  constructor(config) {
    this.apiKey = config.apiKey;
    this.baseUrl = config.baseUrl || "https://data.solanatracker.io";
  }
  /**
   * Makes a request to the API
   * @param endpoint The API endpoint
   * @param options Additional fetch options
   * @returns The API response
   */
  async request(endpoint, options) {
    const headers = {
      "x-api-key": this.apiKey,
      "Content-Type": "application/json",
      ...options == null ? void 0 : options.headers
    };
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        ...options,
        headers
      });
      if (!response.ok) {
        if (response.status === 429) {
          const retryAfter = response.headers.get("Retry-After");
          if (options == null ? void 0 : options.disableLogs) {
            console.warn(`Rate limit exceeded for ${endpoint}. Retry after: ${retryAfter || "1"} seconds`);
          }
          throw new RateLimitError(
            "Rate limit exceeded",
            retryAfter ? parseInt(retryAfter) : void 0
          );
        }
        throw new DataApiError(
          `API request failed: ${response.status} ${response.statusText}`,
          response.status
        );
      }
      return response.json();
    } catch (error) {
      if (error instanceof DataApiError) {
        throw error;
      }
      throw new DataApiError("An unexpected error occurred");
    }
  }
  /**
   * Validates a Solana public key
   * @param address The address to validate
   * @param paramName The parameter name for error messaging
   * @throws ValidationError if the address is invalid
   */
  validatePublicKey(address, paramName) {
    if (!address || !/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address)) {
      throw new ValidationError(`Invalid ${paramName}: ${address}`);
    }
  }
  // ======== TOKEN ENDPOINTS ========
  /**
   * Get comprehensive information about a specific token
   * @param tokenAddress The token's mint address
   * @returns Detailed token information
   */
  async getTokenInfo(tokenAddress) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request(`/tokens/${tokenAddress}`);
  }
  /**
   * Get token information by searching with a pool address
   * @param poolAddress The pool address
   * @returns Detailed token information
   */
  async getTokenByPool(poolAddress) {
    this.validatePublicKey(poolAddress, "poolAddress");
    return this.request(`/tokens/by-pool/${poolAddress}`);
  }
  /**
   * Get token holders information
   * @param tokenAddress The token's mint address
   * @returns Information about token holders
   */
  async getTokenHolders(tokenAddress) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request(`/tokens/${tokenAddress}/holders`);
  }
  /**
   * Get top 20 token holders
   * @param tokenAddress The token's mint address
   * @returns Top holders information
   */
  async getTopHolders(tokenAddress) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request(`/tokens/${tokenAddress}/holders/top`);
  }
  /**
   * Get the all-time high price for a token
   * @param tokenAddress The token's mint address
   * @returns All-time high price data
   */
  async getAthPrice(tokenAddress) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request(`/tokens/${tokenAddress}/ath`);
  }
  /**
   * Get tokens created by a specific wallet
   * @param wallet The deployer wallet address
   * @returns List of tokens created by the deployer
   */
  async getTokensByDeployer(wallet) {
    this.validatePublicKey(wallet, "wallet");
    return this.request(`/deployer/${wallet}`);
  }
  /**
   * Search for tokens with flexible filtering options
   * @param params Search parameters and filters
   * @returns Search results
   */
  async searchTokens(params) {
    const queryParams = new URLSearchParams();
    for (const [key, value] of Object.entries(params)) {
      if (value !== void 0) {
        queryParams.append(key, value.toString());
      }
    }
    return this.request(`/search?${queryParams}`);
  }
  /**
   * Get the latest tokens
   * @param page Page number (1-10)
   * @returns List of latest tokens
   */
  async getLatestTokens(page = 1) {
    if (page < 1 || page > 10) {
      throw new ValidationError("Page must be between 1 and 10");
    }
    return this.request(`/tokens/latest?page=${page}`);
  }
  /**
   * Get information about multiple tokens
   * @param tokenAddresses Array of token addresses
   * @returns Information about multiple tokens
   */
  async getMultipleTokens(tokenAddresses) {
    if (tokenAddresses.length > 20) {
      throw new ValidationError("Maximum of 20 tokens per request");
    }
    tokenAddresses.forEach((addr) => this.validatePublicKey(addr, "tokenAddress"));
    return this.request("/tokens/multi", {
      method: "POST",
      body: JSON.stringify({ tokens: tokenAddresses })
    });
  }
  /**
   * Get trending tokens
   * @param timeframe Optional timeframe for trending calculation
   * @returns List of trending tokens
   */
  async getTrendingTokens(timeframe) {
    const validTimeframes = ["5m", "15m", "30m", "1h", "2h", "3h", "4h", "5h", "6h", "12h", "24h"];
    if (timeframe && !validTimeframes.includes(timeframe)) {
      throw new ValidationError(`Invalid timeframe. Must be one of: ${validTimeframes.join(", ")}`);
    }
    const endpoint = timeframe ? `/tokens/trending/${timeframe}` : "/tokens/trending";
    return this.request(endpoint);
  }
  /**
   * Get tokens sorted by volume
   * @param timeframe Optional timeframe for volume calculation
   * @returns List of tokens sorted by volume
   */
  async getTokensByVolume(timeframe) {
    const validTimeframes = ["5m", "15m", "30m", "1h", "6h", "12h", "24h"];
    if (timeframe && !validTimeframes.includes(timeframe)) {
      throw new ValidationError(`Invalid timeframe. Must be one of: ${validTimeframes.join(", ")}`);
    }
    const endpoint = timeframe ? `/tokens/volume/${timeframe}` : "/tokens/volume";
    return this.request(endpoint);
  }
  /**
   * Get an overview of latest, graduating, and graduated tokens
   * @returns Token overview
   */
  async getTokenOverview() {
    return this.request("/tokens/multi/all");
  }
  /**
   * Get graduated tokens
   * @returns List of graduated tokens
   */
  async getGraduatedTokens() {
    return this.request("/tokens/multi/graduated");
  }
  // ======== PRICE ENDPOINTS ========
  /**
   * Get price information for a token
   * @param tokenAddress The token's mint address
   * @param priceChanges Include price change percentages
   * @returns Price data
   */
  async getPrice(tokenAddress, priceChanges) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    const query = priceChanges ? "&priceChanges=true" : "";
    return this.request(`/price?token=${tokenAddress}${query}`);
  }
  /**
   * Get historic price information for a token
   * @param tokenAddress The token's mint address
   * @returns Historic price data
   */
  async getPriceHistory(tokenAddress) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request(`/price/history?token=${tokenAddress}`);
  }
  /**
   * Get price at a specific timestamp
   * @param tokenAddress The token's mint address
   * @param timestamp Unix timestamp
   * @returns Price at the specified timestamp
   */
  async getPriceAtTimestamp(tokenAddress, timestamp) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request(`/price/history/timestamp?token=${tokenAddress}&timestamp=${timestamp}`);
  }
  /**
   * Get lowest and highest price in a time range
   * @param tokenAddress The token's mint address
   * @param timeFrom Start time (unix timestamp)
   * @param timeTo End time (unix timestamp)
   * @returns Price range data
   */
  async getPriceRange(tokenAddress, timeFrom, timeTo) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request(`/price/history/range?token=${tokenAddress}&time_from=${timeFrom}&time_to=${timeTo}`);
  }
  /**
   * Get price information for a token (POST method)
   * @param tokenAddress The token's mint address
   * @param priceChanges Include price change percentages
   * @returns Price data
   */
  async postPrice(tokenAddress, priceChanges) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request("/price", {
      method: "POST",
      body: JSON.stringify({
        token: tokenAddress,
        priceChanges: priceChanges || false
      })
    });
  }
  /**
   * Get price information for multiple tokens
   * @param tokenAddresses Array of token addresses
   * @param priceChanges Include price change percentages
   * @returns Price data for multiple tokens
   */
  async getMultiplePrices(tokenAddresses, priceChanges) {
    if (tokenAddresses.length > 100) {
      throw new ValidationError("Maximum of 100 tokens per request");
    }
    tokenAddresses.forEach((addr) => this.validatePublicKey(addr, "tokenAddress"));
    const query = priceChanges ? "&priceChanges=true" : "";
    return this.request(`/price/multi?tokens=${tokenAddresses.join(",")}${query}`);
  }
  /**
   * Get price information for multiple tokens (POST method)
   * @param tokenAddresses Array of token addresses
   * @param priceChanges Include price change percentages
   * @returns Price data for multiple tokens
   */
  async postMultiplePrices(tokenAddresses, priceChanges) {
    if (tokenAddresses.length > 100) {
      throw new ValidationError("Maximum of 100 tokens per request");
    }
    tokenAddresses.forEach((addr) => this.validatePublicKey(addr, "tokenAddress"));
    return this.request("/price/multi", {
      method: "POST",
      body: JSON.stringify({
        tokens: tokenAddresses,
        priceChanges: priceChanges || false
      })
    });
  }
  // ======== WALLET ENDPOINTS ========
  /**
   * Get basic wallet information
   * @param owner Wallet address
   * @returns Basic wallet data
   */
  async getWalletBasic(owner) {
    this.validatePublicKey(owner, "owner");
    return this.request(`/wallet/${owner}/basic`);
  }
  /**
   * Get all tokens in a wallet
   * @param owner Wallet address
   * @returns Detailed wallet data
   */
  async getWallet(owner) {
    this.validatePublicKey(owner, "owner");
    return this.request(`/wallet/${owner}`);
  }
  /**
   * Get wallet tokens with pagination
   * @param owner Wallet address
   * @param page Page number
   * @returns Paginated wallet data
   */
  async getWalletPage(owner, page) {
    this.validatePublicKey(owner, "owner");
    return this.request(`/wallet/${owner}/page/${page}`);
  }
  /**
   * Get wallet trades
   * @param owner Wallet address
   * @param cursor Pagination cursor
   * @param showMeta Include token metadata
   * @param parseJupiter Parse Jupiter swaps
   * @param hideArb Hide arbitrage transactions
   * @returns Wallet trades data
   */
  async getWalletTrades(owner, cursor, showMeta, parseJupiter, hideArb) {
    this.validatePublicKey(owner, "owner");
    const params = new URLSearchParams();
    if (cursor) params.append("cursor", cursor.toString());
    if (showMeta) params.append("showMeta", "true");
    if (parseJupiter) params.append("parseJupiter", "true");
    if (hideArb) params.append("hideArb", "true");
    const query = params.toString() ? `?${params.toString()}` : "";
    return this.request(`/wallet/${owner}/trades${query}`);
  }
  // ======== TRADE ENDPOINTS ========
  /**
   * Get trades for a token
   * @param tokenAddress Token address
   * @param cursor Pagination cursor
   * @param showMeta Include token metadata
   * @param parseJupiter Parse Jupiter swaps
   * @param hideArb Hide arbitrage transactions
   * @returns Token trades data
   */
  async getTokenTrades(tokenAddress, cursor, showMeta, parseJupiter, hideArb) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    const params = new URLSearchParams();
    if (cursor) params.append("cursor", cursor.toString());
    if (showMeta) params.append("showMeta", "true");
    if (parseJupiter) params.append("parseJupiter", "true");
    if (hideArb) params.append("hideArb", "true");
    const query = params.toString() ? `?${params.toString()}` : "";
    return this.request(`/trades/${tokenAddress}${query}`);
  }
  /**
   * Get trades for a specific token and pool
   * @param tokenAddress Token address
   * @param poolAddress Pool address
   * @param cursor Pagination cursor
   * @param showMeta Include token metadata
   * @param parseJupiter Parse Jupiter swaps
   * @param hideArb Hide arbitrage transactions
   * @returns Pool-specific token trades data
   */
  async getPoolTrades(tokenAddress, poolAddress, cursor, showMeta, parseJupiter, hideArb) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    this.validatePublicKey(poolAddress, "poolAddress");
    const params = new URLSearchParams();
    if (cursor) params.append("cursor", cursor.toString());
    if (showMeta) params.append("showMeta", "true");
    if (parseJupiter) params.append("parseJupiter", "true");
    if (hideArb) params.append("hideArb", "true");
    const query = params.toString() ? `?${params.toString()}` : "";
    return this.request(`/trades/${tokenAddress}/${poolAddress}${query}`);
  }
  /**
   * Get trades for a specific token, pool, and wallet
   * @param tokenAddress Token address
   * @param poolAddress Pool address
   * @param owner Wallet address
   * @param cursor Pagination cursor
   * @param showMeta Include token metadata
   * @param parseJupiter Parse Jupiter swaps
   * @param hideArb Hide arbitrage transactions
   * @returns User-specific pool trades data
   */
  async getUserPoolTrades(tokenAddress, poolAddress, owner, cursor, showMeta, parseJupiter, hideArb) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    this.validatePublicKey(poolAddress, "poolAddress");
    this.validatePublicKey(owner, "owner");
    const params = new URLSearchParams();
    if (cursor) params.append("cursor", cursor.toString());
    if (showMeta) params.append("showMeta", "true");
    if (parseJupiter) params.append("parseJupiter", "true");
    if (hideArb) params.append("hideArb", "true");
    const query = params.toString() ? `?${params.toString()}` : "";
    return this.request(`/trades/${tokenAddress}/${poolAddress}/${owner}${query}`);
  }
  /**
   * Get trades for a specific token and wallet
   * @param tokenAddress Token address
   * @param owner Wallet address
   * @param cursor Pagination cursor
   * @param showMeta Include token metadata
   * @param parseJupiter Parse Jupiter swaps
   * @param hideArb Hide arbitrage transactions
   * @returns User-specific token trades data
   */
  async getUserTokenTrades(tokenAddress, owner, cursor, showMeta, parseJupiter, hideArb) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    this.validatePublicKey(owner, "owner");
    const params = new URLSearchParams();
    if (cursor) params.append("cursor", cursor.toString());
    if (showMeta) params.append("showMeta", "true");
    if (parseJupiter) params.append("parseJupiter", "true");
    if (hideArb) params.append("hideArb", "true");
    const query = params.toString() ? `?${params.toString()}` : "";
    return this.request(`/trades/${tokenAddress}/by-wallet/${owner}${query}`);
  }
  // ======== CHART DATA ENDPOINTS ========
  /**
   * Get OHLCV data for a token
   * @param tokenAddress Token address
   * @param type Time interval (e.g., "1s", "1m", "1h", "1d")
   * @param timeFrom Start time (Unix timestamp in seconds)
   * @param timeTo End time (Unix timestamp in seconds)
   * @param marketCap Return chart for market cap instead of pricing
   * @param removeOutliers Disable outlier removal if set to false (default: true)
   * @returns OHLCV chart data
   */
  async getChartData(tokenAddress, type, timeFrom, timeTo, marketCap, removeOutliers) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    const params = new URLSearchParams();
    if (type) params.append("type", type);
    if (timeFrom) params.append("time_from", timeFrom.toString());
    if (timeTo) params.append("time_to", timeTo.toString());
    if (marketCap) params.append("marketCap", "true");
    if (removeOutliers === false) params.append("removeOutliers", "false");
    const query = params.toString() ? `?${params.toString()}` : "";
    return this.request(`/chart/${tokenAddress}${query}`);
  }
  /**
   * Get OHLCV data for a specific token and pool
   * @param tokenAddress Token address
   * @param poolAddress Pool address
   * @param type Time interval (e.g., "1s", "1m", "1h", "1d")
   * @param timeFrom Start time (Unix timestamp in seconds)
   * @param timeTo End time (Unix timestamp in seconds)
   * @param marketCap Return chart for market cap instead of pricing
   * @param removeOutliers Disable outlier removal if set to false (default: true)
   * @returns OHLCV chart data for a specific pool
   */
  async getPoolChartData(tokenAddress, poolAddress, type, timeFrom, timeTo, marketCap, removeOutliers) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    this.validatePublicKey(poolAddress, "poolAddress");
    const params = new URLSearchParams();
    if (type) params.append("type", type);
    if (timeFrom) params.append("time_from", timeFrom.toString());
    if (timeTo) params.append("time_to", timeTo.toString());
    if (marketCap) params.append("marketCap", "true");
    if (removeOutliers === false) params.append("removeOutliers", "false");
    const query = params.toString() ? `?${params.toString()}` : "";
    return this.request(`/chart/${tokenAddress}/${poolAddress}${query}`);
  }
  /**
   * Get holder count chart data
   * @param tokenAddress Token address
   * @param type Time interval (e.g., "1s", "1m", "1h", "1d")
   * @param timeFrom Start time (Unix timestamp in seconds)
   * @param timeTo End time (Unix timestamp in seconds)
   * @returns Holder count chart data
   */
  async getHoldersChart(tokenAddress, type, timeFrom, timeTo) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    const params = new URLSearchParams();
    if (type) params.append("type", type);
    if (timeFrom) params.append("time_from", timeFrom.toString());
    if (timeTo) params.append("time_to", timeTo.toString());
    const query = params.toString() ? `?${params.toString()}` : "";
    return this.request(`/holders/chart/${tokenAddress}${query}`);
  }
  // ======== PNL DATA ENDPOINTS ========
  /**
   * Get PnL data for all positions of a wallet
   * @param wallet Wallet address
   * @param showHistoricPnL Add PnL data for 1d, 7d and 30d intervals (BETA)
   * @param holdingCheck Additional check for current holding value
   * @param hideDetails Return only summary without data for each token
   * @returns Wallet PnL data
   */
  async getWalletPnL(wallet, showHistoricPnL, holdingCheck, hideDetails) {
    this.validatePublicKey(wallet, "wallet");
    const params = new URLSearchParams();
    if (showHistoricPnL) params.append("showHistoricPnL", "true");
    if (holdingCheck) params.append("holdingCheck", "true");
    if (hideDetails) params.append("hideDetails", "true");
    const query = params.toString() ? `?${params.toString()}` : "";
    return this.request(`/pnl/${wallet}${query}`);
  }
  /**
   * Get the first 100 buyers of a token with PnL data
   * @param tokenAddress Token address
   * @returns First buyers data with PnL
   */
  async getFirstBuyers(tokenAddress) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request(`/first-buyers/${tokenAddress}`);
  }
  /**
   * Get PnL data for a specific token in a wallet
   * @param wallet Wallet address
   * @param tokenAddress Token address
   * @returns Token-specific PnL data
   */
  async getTokenPnL(wallet, tokenAddress) {
    this.validatePublicKey(wallet, "wallet");
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request(`/pnl/${wallet}/${tokenAddress}`);
  }
  // ======== TOP TRADERS ENDPOINTS ========
  /**
   * Get the most profitable traders across all tokens
   * @param page Page number (optional)
   * @param expandPnL Include detailed PnL data for each token
   * @param sortBy Sort results by metric ("total" or "winPercentage")
   * @returns Top traders data
   */
  async getTopTraders(page, expandPnL, sortBy) {
    const params = new URLSearchParams();
    if (expandPnL) params.append("expandPnL", "true");
    if (sortBy) params.append("sortBy", sortBy);
    const query = params.toString() ? `?${params.toString()}` : "";
    const endpoint = page ? `/top-traders/all/${page}${query}` : `/top-traders/all${query}`;
    return this.request(endpoint);
  }
  /**
   * Get top 100 traders by PnL for a token
   * @param tokenAddress Token address
   * @returns Top traders for a specific token
   */
  async getTokenTopTraders(tokenAddress) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request(`/top-traders/${tokenAddress}`);
  }
  // ======== ADDITIONAL ENDPOINTS ========
  /**
   * Get detailed stats for a token over various time intervals
   * @param tokenAddress Token address
   * @returns Detailed token stats
   */
  async getTokenStats(tokenAddress) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    return this.request(`/stats/${tokenAddress}`);
  }
  /**
   * Get detailed stats for a specific token and pool
   * @param tokenAddress Token address
   * @param poolAddress Pool address
   * @returns Detailed token-pool stats
   */
  async getPoolStats(tokenAddress, poolAddress) {
    this.validatePublicKey(tokenAddress, "tokenAddress");
    this.validatePublicKey(poolAddress, "poolAddress");
    return this.request(`/stats/${tokenAddress}/${poolAddress}`);
  }
};

// src/datastream.ts
var import_events = require("events");

// src/websocket-polyfill.ts
var isBrowser = typeof window !== "undefined" && typeof window.WebSocket !== "undefined";
if (!isBrowser) {
  try {
    const WebSocketImpl = require("ws");
    if (typeof global !== "undefined" && !global.WebSocket) {
      global.WebSocket = WebSocketImpl;
    }
  } catch (e) {
    console.warn(
      'WebSocket implementation not found. If you are using Node.js, please install the "ws" package: npm install ws'
    );
  }
}

// src/datastream.ts
var DatastreamRoom = /* @__PURE__ */ ((DatastreamRoom2) => {
  DatastreamRoom2["LATEST"] = "latest";
  DatastreamRoom2["PRICE_BY_TOKEN"] = "price-by-token";
  DatastreamRoom2["PRICE_BY_POOL"] = "price";
  DatastreamRoom2["TOKEN_TRANSACTIONS"] = "transaction";
  DatastreamRoom2["WALLET_TRANSACTIONS"] = "wallet";
  DatastreamRoom2["GRADUATING"] = "graduating";
  DatastreamRoom2["GRADUATED"] = "graduated";
  DatastreamRoom2["METADATA"] = "metadata";
  DatastreamRoom2["HOLDERS"] = "holders";
  DatastreamRoom2["TOKEN_CHANGES"] = "token";
  DatastreamRoom2["POOL_CHANGES"] = "pool";
  return DatastreamRoom2;
})(DatastreamRoom || {});
var SubscriptionMethods = class {
  constructor(datastream) {
    this.ds = datastream;
    this.price = new PriceSubscriptions(datastream);
    this.tx = new TransactionSubscriptions(datastream);
  }
  /**
   * Subscribe to latest tokens and pools
   */
  latest() {
    return this.ds._subscribe("latest");
  }
  /**
   * Subscribe to graduating tokens
   * @param marketCapThresholdSOL Optional market cap threshold in SOL
   */
  graduating(marketCapThresholdSOL) {
    const room = marketCapThresholdSOL ? `graduating:sol:${marketCapThresholdSOL}` : "graduating";
    return this.ds._subscribe(room);
  }
  /**
   * Subscribe to graduated tokens
   */
  graduated() {
    return this.ds._subscribe("graduated");
  }
  /**
   * Subscribe to token metadata updates
   * @param tokenAddress The token address
   */
  metadata(tokenAddress) {
    return this.ds._subscribe(`metadata:${tokenAddress}`);
  }
  /**
   * Subscribe to holder count updates for a token
   * @param tokenAddress The token address
   */
  holders(tokenAddress) {
    return this.ds._subscribe(`holders:${tokenAddress}`);
  }
  /**
   * Subscribe to token changes (any pool)
   * @param tokenAddress The token address
   */
  token(tokenAddress) {
    return this.ds._subscribe(`token:${tokenAddress}`);
  }
  /**
   * Subscribe to pool changes
   * @param poolId The pool address
   */
  pool(poolId) {
    return this.ds._subscribe(`pool:${poolId}`);
  }
};
var PriceSubscriptions = class {
  constructor(datastream) {
    this.ds = datastream;
  }
  /**
   * Subscribe to price updates for a token's primary/largest pool
   * @param tokenAddress The token address
   */
  token(tokenAddress) {
    return this.ds._subscribe(`price-by-token:${tokenAddress}`);
  }
  /**
   * Subscribe to all price updates for a token across all pools
   * @param tokenAddress The token address
   */
  allPoolsForToken(tokenAddress) {
    return this.ds._subscribe(`price:${tokenAddress}`);
  }
  /**
   * Subscribe to price updates for a specific pool
   * @param poolId The pool address
   */
  pool(poolId) {
    return this.ds._subscribe(`price:${poolId}`);
  }
};
var TransactionSubscriptions = class {
  constructor(datastream) {
    this.ds = datastream;
  }
  /**
   * Subscribe to transactions for a token across all pools
   * @param tokenAddress The token address
   */
  token(tokenAddress) {
    return this.ds._subscribe(`transaction:${tokenAddress}`);
  }
  /**
   * Subscribe to transactions for a specific token and pool
   * @param tokenAddress The token address
   * @param poolId The pool address
   */
  pool(tokenAddress, poolId) {
    return this.ds._subscribe(`transaction:${tokenAddress}:${poolId}`);
  }
  /**
   * Subscribe to transactions for a specific wallet
   * @param walletAddress The wallet address
   */
  wallet(walletAddress) {
    return this.ds._subscribe(`wallet:${walletAddress}`);
  }
};
var Datastream = class extends import_events.EventEmitter {
  /**
   * Creates a new Datastream client for real-time Solana Tracker data
   * @param config Configuration options
   */
  constructor(config) {
    super();
    this.socket = null;
    this.transactionSocket = null;
    this.reconnectAttempts = 0;
    this.subscribedRooms = /* @__PURE__ */ new Set();
    this.transactions = /* @__PURE__ */ new Set();
    this.isConnecting = false;
    this.wsUrl = config.wsUrl || "";
    this.autoReconnect = config.autoReconnect !== false;
    this.reconnectDelay = config.reconnectDelay || 2500;
    this.reconnectDelayMax = config.reconnectDelayMax || 4500;
    this.randomizationFactor = config.randomizationFactor || 0.5;
    this.subscribe = new SubscriptionMethods(this);
    if (typeof window !== "undefined") {
      window.addEventListener("beforeunload", this.disconnect.bind(this));
    }
  }
  /**
   * Connects to the WebSocket server
   * @returns Promise that resolves when connected
   */
  async connect() {
    if (this.socket && this.transactionSocket) {
      return;
    }
    if (this.isConnecting) {
      return;
    }
    this.isConnecting = true;
    try {
      await Promise.all([
        this.createSocket("main"),
        this.createSocket("transaction")
      ]);
      this.isConnecting = false;
      this.emit("connected");
    } catch (e) {
      this.isConnecting = false;
      this.emit("error", e);
      if (this.autoReconnect) {
        this.reconnect();
      }
    }
  }
  /**
   * Creates a WebSocket connection
   * @param type Socket type ('main' or 'transaction')
   * @returns Promise that resolves when connected
   */
  createSocket(type) {
    return new Promise((resolve, reject) => {
      try {
        const socket = new WebSocket(this.wsUrl);
        socket.onopen = () => {
          if (type === "main") {
            this.socket = socket;
          } else {
            this.transactionSocket = socket;
          }
          this.reconnectAttempts = 0;
          this.setupSocketListeners(socket, type);
          this.resubscribeToRooms();
          resolve();
        };
        socket.onerror = (error) => {
          reject(error);
        };
      } catch (e) {
        reject(e);
      }
    });
  }
  /**
   * Sets up WebSocket event listeners
   * @param socket The WebSocket connection
   * @param type Socket type ('main' or 'transaction')
   */
  setupSocketListeners(socket, type) {
    socket.onmessage = (event) => {
      var _a, _b;
      try {
        const message = JSON.parse(event.data);
        if (message.type === "message") {
          if (((_a = message.data) == null ? void 0 : _a.tx) && this.transactions.has(message.data.tx)) {
            return;
          } else if ((_b = message.data) == null ? void 0 : _b.tx) {
            this.transactions.add(message.data.tx);
          }
          if (message.room.includes("price:")) {
            this.emit(`price-by-token:${message.data.token}`, message.data);
          }
          this.emit(message.room, message.data);
        }
      } catch (error) {
        this.emit("error", new Error(`Error processing message: ${error}`));
      }
    };
    socket.onclose = () => {
      this.emit("disconnected", type);
      if (type === "main") {
        this.socket = null;
      } else if (type === "transaction") {
        this.transactionSocket = null;
      }
      if (this.autoReconnect) {
        this.reconnect();
      }
    };
  }
  /**
   * Disconnects from the WebSocket server
   */
  disconnect() {
    if (this.socket) {
      this.socket.close();
      this.socket = null;
    }
    if (this.transactionSocket) {
      this.transactionSocket.close();
      this.transactionSocket = null;
    }
    this.subscribedRooms.clear();
    this.transactions.clear();
    this.emit("disconnected", "all");
  }
  /**
   * Handles reconnection to the WebSocket server
   */
  reconnect() {
    if (!this.autoReconnect) return;
    this.emit("reconnecting", this.reconnectAttempts);
    const delay = Math.min(
      this.reconnectDelay * Math.pow(2, this.reconnectAttempts),
      this.reconnectDelayMax
    );
    const jitter = delay * this.randomizationFactor;
    const reconnectDelay = delay + Math.random() * jitter;
    setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, reconnectDelay);
  }
  /**
   * Subscribes to a data room
   * @param room The room name to join
   * @returns Response with room name and on() method for listening
   * @internal Used by SubscriptionMethods
   */
  _subscribe(room) {
    this.subscribedRooms.add(room);
    const socket = room.includes("transaction") ? this.transactionSocket : this.socket;
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "join", room }));
    } else {
      this.connect();
    }
    return {
      room,
      on: (callback) => {
        const wrappedCallback = (data) => {
          if (Array.isArray(data)) {
            data.forEach((item) => callback(item));
          } else {
            callback(data);
          }
        };
        this.on(room, wrappedCallback);
        return {
          unsubscribe: () => {
            this.removeListener(room, wrappedCallback);
          }
        };
      }
    };
  }
  on(event, listener) {
    return super.on(event, listener);
  }
  once(event, listener) {
    return super.once(event, listener);
  }
  off(event, listener) {
    return super.off(event, listener);
  }
  removeListener(event, listener) {
    return super.removeListener(event, listener);
  }
  removeAllListeners(event) {
    return super.removeAllListeners(event);
  }
  listeners(event) {
    return super.listeners(event);
  }
  /**
   * Unsubscribes from a data room
   * @param room The room name to leave
   * @returns Reference to this instance for chaining
   */
  unsubscribe(room) {
    this.subscribedRooms.delete(room);
    const socket = room.includes("transaction") ? this.transactionSocket : this.socket;
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "leave", room }));
    }
    return this;
  }
  /**
   * Resubscribes to all previously subscribed rooms after reconnection
   */
  resubscribeToRooms() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN && this.transactionSocket && this.transactionSocket.readyState === WebSocket.OPEN) {
      for (const room of this.subscribedRooms) {
        const socket = room.includes("transaction") ? this.transactionSocket : this.socket;
        socket.send(JSON.stringify({ type: "join", room }));
      }
    }
  }
  /**
   * Get the current connection status
   * @returns True if connected, false otherwise
   */
  isConnected() {
    return !!this.socket && this.socket.readyState === WebSocket.OPEN && !!this.transactionSocket && this.transactionSocket.readyState === WebSocket.OPEN;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Client,
  DataApiError,
  Datastream,
  DatastreamRoom,
  RateLimitError,
  ValidationError
});
